using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ZirconNet.WPF.SourceGenerator.Mvvm;

[Generator]
public class HostIntegrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find the App class that derives from System.Windows.Application
        var appClasses = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) =>
                node is ClassDeclarationSyntax { Identifier.ValueText: "App" } cds && cds.BaseList != null,
            transform: static (ctx, _) =>
            {
                var classDeclaration = (ClassDeclarationSyntax)ctx.Node;
                if (ctx.SemanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol symbol)
                {
                    return null;
                }
                for (var baseType = symbol.BaseType; baseType is not null; baseType = baseType.BaseType)
                {
                    if (baseType.ToDisplayString() == "System.Windows.Application")
                    {
                        return symbol;
                    }
                }
                return null;
            })
        .Where(static symbol => symbol is not null);

        // Generate both the App partial file and the helper extensions file in one go.
        context.RegisterSourceOutput(appClasses.Collect(), (spc, appSymbols) =>
        {
            var appSymbol = appSymbols.FirstOrDefault();
            if (appSymbol is null)
            {
                return;
            }
            var appNamespace = appSymbol.ContainingNamespace.ToDisplayString();

            var appSource = GenerateHostIntegrationPartial(appSymbol);
            spc.AddSource($"ZirconNet.WPF.SourceGenerator.HostIntegration_{appSymbol.Name}.g.cs", SourceText.From(appSource, Encoding.UTF8));

            var helperSource = GetHelperExtensionsSource(appNamespace);
            spc.AddSource("ZirconNet.WPF.SourceGenerator.WpfApplicationLifeTimeExtensions.g.cs", SourceText.From(helperSource, Encoding.UTF8));
        });
    }

    private static string GenerateHostIntegrationPartial(INamedTypeSymbol appSymbol)
    {
        var namespaceName = appSymbol.ContainingNamespace.ToDisplayString();
        var className = appSymbol.Name;
        return $$"""
// <auto-generated />
#nullable enable
using System;
using System.Threading.Tasks;
using System.Windows;
using Microsoft.Extensions.Hosting;

namespace {{namespaceName}}
{
    public partial class {{className}}
    {
        public IHost Host { get; set; } = default!;
    }
}
""";
    }

    private static string GetHelperExtensionsSource(string appNamespace)
    {
        return $$"""
// <auto-generated />
#nullable enable
using {{appNamespace}};
using System.Diagnostics;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using System.Threading;
using System.Threading.Tasks;
#if NET5_0_OR_GREATER
using System.Runtime.Versioning;
#endif
using System.Windows;
using ZirconNet.Core.Environments;
using ZirconNet.WPF.Debugging;
using ZirconNet.WPF.Extensions;
using ZirconNet.WPF.Hosting.Lifetime;

namespace ZirconNet.WPF.SourceGenerator.Hosting.Lifetime
{
    public static class WpfApplicationLifeTimeExtensions
    {
#if NET6_0_OR_GREATER
#if NET5_0_OR_GREATER
        [SupportedOSPlatform("windows")]
#endif
        public static IHostApplicationBuilder UseWpfApplicationLifetime(this IHostApplicationBuilder builder)
        {
            builder.Services.AddSingleton<IHostLifetime, WpfApplicationLifetime>();
            return builder;
        }
#if NET5_0_OR_GREATER
        [SupportedOSPlatform("windows")]
#endif
        public static IHostApplicationBuilder UseWpfApplicationLifetime(this IHostApplicationBuilder builder, Action<WpfApplicationLifetimeOptions> configureOptions)
        {
            builder.Services.AddSingleton<IHostLifetime, WpfApplicationLifetime>();
            builder.Services.Configure(configureOptions);
            return builder;
        }
        public static Task RunWpfApplicationAsync<T>(this HostApplicationBuilder builder, bool showConsoleWithDebugger = false, bool showConsoleWithDebugEnvironment = false, CancellationToken cancellationToken = default)
            where T : Window
        {
            builder.UseWpfApplicationLifetime();
            return RunWpfApplicationAsyncInternal<T>(builder, showConsoleWithDebugger, showConsoleWithDebugEnvironment, cancellationToken);
        }
        public static Task RunWpfApplicationAsync<T>(this HostApplicationBuilder builder, Action<WpfApplicationLifetimeOptions> configureOptions, bool showConsoleWithDebugger = false, bool showConsoleWithDebugEnvironment = false, CancellationToken cancellationToken = default)
            where T : Window
        {
            builder.UseWpfApplicationLifetime(configureOptions);
            return RunWpfApplicationAsyncInternal<T>(builder, showConsoleWithDebugger, showConsoleWithDebugEnvironment, cancellationToken);
        }
        private static async Task RunWpfApplicationAsyncInternal<T>(HostApplicationBuilder builder, bool showConsoleWithDebugger, bool showConsoleWithDebugEnvironment, CancellationToken cancellationToken)
            where T : Window
        {
            ToggleDebugConsole(showConsoleWithDebugger, showConsoleWithDebugEnvironment);
            builder.Services.AddSingleton<T>();
            using var host = builder.Build();
            ((App)Application.Current).Host = host;
            var window = host.Services.GetRequiredService<T>();
            var applicationLifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();
            applicationLifetime.ApplicationStopped.Register(() => host?.Dispose());
            await host.StartAsync(cancellationToken).ConfigureAwait(false);
            await window.ShowDialogAsync().ConfigureAwait(false);
            ToggleDebugConsole(showConsoleWithDebugger, showConsoleWithDebugEnvironment);
            await host.StopAsync(cancellationToken).ConfigureAwait(false);
        }
#else
#if NET5_0_OR_GREATER
        [SupportedOSPlatform("windows")]
#endif
        public static IHostBuilder UseWpfApplicationLifetime(this IHostBuilder builder)
        {
            return builder.ConfigureServices(services => services.AddSingleton<IHostLifetime, WpfApplicationLifetime>());
        }
#if NET5_0_OR_GREATER
        [SupportedOSPlatform("windows")]
#endif
        public static IHostBuilder UseWpfApplicationLifetime(this IHostBuilder builder, Action<WpfApplicationLifetimeOptions> configureOptions)
        {
            return builder.ConfigureServices(services =>
            {
                services.TryAddSingleton<IHostLifetime, WpfApplicationLifetime>();
                services.Configure(configureOptions);
            });
        }
        public static Task RunWpfApplicationAsync<T>(this IHostBuilder builder, bool showConsoleWithDebugger = false, bool showConsoleWithDebugEnvironment = false, CancellationToken cancellationToken = default)
            where T : Window
        {
            builder.UseWpfApplicationLifetime();
            return RunWpfApplicationAsyncInternal<T>(builder, showConsoleWithDebugger, showConsoleWithDebugEnvironment, cancellationToken);
        }
        public static Task RunWpfApplicationAsync<T>(this IHostBuilder builder, Action<WpfApplicationLifetimeOptions> configureOptions, bool showConsoleWithDebugger = false, bool showConsoleWithDebugEnvironment = false, CancellationToken cancellationToken = default)
            where T : Window
        {
            builder.UseWpfApplicationLifetime(configureOptions);
            return RunWpfApplicationAsyncInternal<T>(builder, showConsoleWithDebugger, showConsoleWithDebugEnvironment, cancellationToken);
        }
        private static async Task RunWpfApplicationAsyncInternal<T>(IHostBuilder builder, bool showConsoleWithDebugger, bool showConsoleWithDebugEnvironment, CancellationToken cancellationToken)
            where T : Window
        {
            ToggleDebugConsole(showConsoleWithDebugger, showConsoleWithDebugEnvironment);
            builder.ConfigureServices(services => services.AddSingleton<T>());
            using var host = builder.Build();
            ((App)Application.Current).Host = host;
            var window = host.Services.GetRequiredService<T>();
            var applicationLifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();
            applicationLifetime.ApplicationStopped.Register(() => host?.Dispose());
            await host.StartAsync(cancellationToken).ConfigureAwait(false);
            await window.ShowDialogAsync().ConfigureAwait(false);
            ToggleDebugConsole(showConsoleWithDebugger, showConsoleWithDebugEnvironment);
            await host.StopAsync(cancellationToken).ConfigureAwait(false);
        }
#endif
        private static void ToggleDebugConsole(bool showConsoleWithDebugger, bool showConsoleWithDebugEnvironment)
        {
            if ((EnvironmentManager.Current.IsDebug && showConsoleWithDebugEnvironment)
                || (Debugger.IsAttached && showConsoleWithDebugger))
            {
                ConsoleManager.Toggle();
            }
        }
    }
}
""";
    }
}
